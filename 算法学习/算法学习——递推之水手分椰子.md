原文链接：http://www.cnblogs.com/kexing/archive/2018/11/06/9916245.html
## 算法描述

>五个水手来到一个岛上，采了一堆椰子后，因为疲劳都睡着了。一段时间后，第一个水手醒来，悄悄地将椰子等分成五份，多出一个椰子，便给了旁边的猴子，然后自己藏起一份，再将剩下的椰子重新合在一起，继续睡觉。不久，第二名水手醒来，同样将椰子了等分成五份，恰好也多出一个，也给了猴子。然而自己也藏起一份，再将剩下的椰子重新合在一起。以后每个水手都如此分了一次并都藏起一份，也恰好都把多出的一个给了猴子。第二天，五个水手醒来，发现椰子少了许多，心照不喧，便把剩下的椰子分成五份，恰好又多出一个，给了猴子。请问水手最初最少摘了多少个椰子？


## 算法思路

1. 这里需要注意的是，没有初始条件，求最初最少摘了多少个椰子

2. y[i] 代表第i个水手偷藏的椰子

	由题目可以得到 个迭代方程 `n/5 = (n-n/5-1)/5`
	
	这里等式左边是第1个水手所藏的椰子数，右边则是下一个水手所藏的椰子数
	
	化简可得递推公式`y[i+1]=(4y[i]-1)/5` 从前往后推

3. 当每次递推的所藏椰子数为正整数，则满足条件，这里通过使用`floor`函数可以判定一个数是否为整数

## 算法实现

		int i =1;
		double k,y,x;
		k=1.0;
		y=k;
		while(i<=5){
			i++;
			y = (4*y-1)/5;
			if(y!=Math.floor(y)){
				k++;
				y=k;
				i=1;
			}
		}
		x=5*k+1;
		System.out.println("椰子至少有"+x+"个");

## 结果
![](https://img2018.cnblogs.com/blog/1210268/201811/1210268-20181106164532964-832410084.png)